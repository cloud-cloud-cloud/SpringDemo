#### :snail: java多线程并发
 ##### java的内存模型
 1.volatile关键字，修饰的共享变量，上一次的写入操作结果对下一次的读取操作是肯定是可见的。在写入volatile变量之后，CPU的缓存中的内容会被写回内存；在读取volatile变量时，CPU缓存中的对应内容会被置为失效，重新从主从中读取。
 volatile不使用锁，所以性能优于synchronize关键字。
 2.final关键字：fina关键字声明的的域的值只能被初始化一次，一般在构造方法里面初始化。（在多线程里面，final的域通常用来实现不可变对象）
 当对象中的共享变量的值不可能发生变化的时候，在多线程中也就不需要同步机制来进行处理，故而在线程里面用尽可能使用不可变对象。
 另外在代码执行时候，final域的值可以被保存在寄存器中，而不用从主从中的频繁重新读取。
 3.java基本类型的原子操作：double,long的赋值，引用是分隔的，必须在synchronize或者volatile操作

  #####  java提供线程同步的方式
  - synchronize关键字
  - Object类的wait（），notify,notifyAll()；（在阻塞队列里面的使用 lock,unlock,wait,notify,）
   调用wait(）方法的对象进入等待池，并释放锁。
   notify()从等待池里面捞一个线程放入睡醒的锁池，当当前线程结束后释放掉锁，锁池中的线程即可竞争对象的锁来获取锁的执行机会。

   1.方法sleep()进入阻塞状态，不会释放对象锁（就是说要睡大家一起睡，所以不要让sleep出现在synchronize里面会造成其他等待锁的线程一直处于等待状态）
   2. join（）则是主线程main 等待子线程执行完毕再往下执行；
   3.interrupt（）中断方法
   4.yield（）尝试让出所占有的CPU资源，让其他线程获取运行机会，对操作系统上面的调度器来说是一个信号不一定立即切换线程。（在实际开发中，测试阶段频繁调用yeid方法使线程切换更频繁，从而让一些多线程相关的错误更容易暴露出来）。

  #####  非阻塞方式


  #####  高级同步对象（信号量samaphore类）
  - 信号量一般用来数量有限的资源，每类资源有一个对象的信号量，信号量的值表示资源的可用数。
  在使用信号量时，需要从改信号量上获取成功，成功获取许可，资源的可用数-1，完成对资源的使用，释放资源，可用资源数+1.
  当资源数为0 的时候需要获取资源的线程以阻塞的方式进行等待，或者过段时间来查询是否有资源。
  java.util.current.samaphore 在创建samaphore类的对象时指定资源的可用数。
  1.acquire()以阻塞的方式获取资源许可；
  2.tryAcquire()以非阻塞方式获取资源许可；
  3.release()释放许可；
  4.AcquireUninteruptibly()，acquire（）方法获取许可的过程中可以被中断，然后不希望被中断使用该方法。
  - 倒数闸门CountDownLatch
  在多线程中一个线程完成任务下一个线程才能继续进行。利用该类指定等待的任务数，当一个任务完成时候调用countDown();

  - 循环屏障（CyclicBarrier）
  循环屏障的作用类似倒数闸门，不过不像countdownLatch是一次性的，他可以循环使用。另外，线程之间是互相平等的。例如说一个线程完成任务，另外一个线程也完成任务，当所有线程都完成某项任务或者各自的任务后，再继续进行下面的任务（类似我们玩游戏升级，多个玩家都要同时做某项任务后，才能进行下一项任务）

  - 对象交换器（Exchanger）
  java.util.current.exchanger 一个线程执行完成后，将结果交给另外一个线程执行

   ##### 数据结构（多线程程序使用高性能的数据结构）



##### extend Thread和implements Runnable的区别及使用
  这个就是继承和接口的区别，


###### 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
     因为调用start方法等于说线程开启，等待CPU资源，当有资源后就就回调用run方法运行，因为如果直接调用run方法等于说主线程执行run方法，没有开启线程等于说这个run方法还是主线程的一个普通方法。


   

