#### :snail: Core java
 ####  Collection类
 #####  List
 ######  在list对int元素去重
 	- list去重  可以通过hashSet不允许重复元素，不保证添加顺序，LinkedHashSet不允许有重复元素但是 可以保证添加顺序
 	- list去重  通过创建一个新的list  通过比对新的数组是否已经放入了这个元素 ，如果已经有了就不放入；另外就是对过比对值如果相等 删除其中一个
 ###### 泛型的使用
 ###### list中含有一个person类中有int age,String name,现在按照age进行升序排序
 ###### list中含有一个person类中有int age,String name,现在按照age进行升序排序，age大小相同，按照name排序
 ###### list转数组的应用。
     list.toArray();
 ######  Arraylist我想固定他的固定容量可以吗，怎么固定？
   List list=Arrays.asList("11","333");//定长 不能添加和删除
 ###### Arraylist是如何自动增加长度的，代码是怎么实现的。

     arrayList是基于数组的，arrayList有一个带参数的构造函数，参数的意思是他的长度，默认的长度是10.当数据多的时候，list会增加长度，
     newLength=oldlength+oldLength/2;所以依次长度为10,15 22,33,49........,新的数组增加长度后，然后将旧的数组的数据拷贝到新的数组里面，
     这就是ArrayList基于数组增加长度的原理。

     int newCapacity=oldCapacity+(oldCapacity>>1)//扩容
     elementData=Arrays.copyOf(elementData,newCapacity);//复制元素

 ###### 一个Arraylist怎么复制到另外一个arrayList？
     list.addAll(list1);
 ######  list与vector区别？
   - vector是分配的一块连接的地址空间，所以对vector元素进行随机访问效率高，不过对其元素进行增加和删除，需要对现有元素进行复制，移动。如果vector储存中的存储对象很大，
     那么对现有元素进行拷贝的开销就回很大。
   - list中的对象是离散存储的，随机访问元素是需要遍历list。在list中插入，删除叶黄素，有钱是在尾部插入原始，效率很高，只需要改变元素的指针。
   - 他们最大的区别是vector是单向的，和数组类似。list数据结构是双向链表，是双向的。


    #####  HashMap
    ######  核心源码的提问
     默认的容量是16，最大的1<<30,加载的因素：0.75f;

    -  哈希表是一种散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（eg:memcached）的核心其实就是维护一张大的哈希表。

    - **数组**：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)

    - **线性链表**：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)

    - **二叉树**：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。

    - **哈希表**：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。
   我们知道，数据结构在物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面提到数组下标查找某个元素是一次定位可以达到的。
   hash table就是利用这个特性，hash table主干是数组。

   hash 函数的计算的重要性涉及到hash冲突的比例，尽可能保证计算简单和散列地址分别均匀。
   hashMap采用了链地址法：数组+链表的方式（hashmap的主干是一个entry[]数组，entry是hashmap的基本组成单位，每一个entry包含一个key-value键值对）
    ![](static/images/hashMap.png)

    计算数组的下标：index=h&(length-1);---------例如说hash值为18，length=16来计算下标
    hashmap的数组长度一定要为2的次幂，尽量减少地址冲突。N^2
    ###### 与HashSet的区别
         - hashSet不允许出现重复元素，无序的，不是按照插入内容进行排序（存储对象之前比较hashcode().equal()或者利用add()判断是否能添加元素）；
         - hashmap实现了map接口，map接口对键值对进行映射。map不允许出现重复的key，map接口有两个基本实现treemap，hashamp。treemap保存了对象的排列次序。
         而hashmap不能，hashmap可以有空的键值对，hashmap是非线程安全的
         - hashmap是调用put添加元素，hashset是调用add来添加元素
         - hashmap是利用key来进行计算hash，hashset利用对象来计算hash
         - hashmap是存储键值对，hashset仅存储对象。
         - hashmap相对于hashset较快，因为它是使用唯一的键获取对象。


    在jdk1.8以前是hashmap组成结构=数组+链表，链表的数据插入是表头插入，为什么表头插入因为在实际开发中发现最新插入的时候，是使用频次最高的，所以放在表头（在原来的表头前面加个元素，然后指针指向下个元素-原表头）
         123---》4123
         在jkd1.8里面是插入到表尾的，因为这个时候添加了红黑树，链表长度最大不超过8，当为8的时候转换为红黑树，所以往表尾插入对查询影响也不大。

    ######  对HashMap如何排序？

   将元素遍历出来放入到list,然后通过list进行排序

    ######  线程安全的问答
    hashMap是线程非安全的，如果想线程安全需要在方法里面添加synchronize关键字。

    #####  Set
    ######  TreeSet排序
        利用compartor进行排序；
    ######  HashSet与hashMap区别

    ######  HashSet的核心源码
    hashset是基于hashmap实现的，操作更简单，更像是对hashmap做了一次“封装”，而且只使用了hashmap的key进行实现各种特性
    #####  LinkList
    ######  linklist是由双向链表实现的（其中每个对象都包含数据的同时还指向链表的前一个和后一个元素的引用），它实现了list，能进行队列操作。
    ArrayList底层是数组支持。
    ######  什么情况下你会使用ArrayList？什么时候你会选择LinkedList？
     arrayList与linkedlist本质区别是数组和列表的两种数据结构的区别：ArrayList使用的内存量更大一些，在随机访问的效率高，删除，添加元素效率低。linkedlist刚好相反。


    ##### iterator
    ###### for循环中怎么使用iterator
     一般arraylist linkedList可以使用for

    ###### while循环中怎么使用iterator
        while(iterator.hashNext()){}

    ###### ListIterator与Iterator的区别
      都是迭代器，当需要对集合进行遍历的时候不需要干涉遍历过程。
      - iterator可以对所有的集合进行遍历，listiterator只能对list和其子类进行遍历；
      - listiterator有add方法可以在当前引用下添加元素，iterator不能添加元素；
      - listiterator可以向前向后遍历，iterator只能向后遍历；
      -
    ##### 泛型
    ###### Java中的泛型是什么 ? 使用泛型的好处是什么?
    - 类型安全
    - 消除强制类型转换；
    - 潜在的性能收益（多态）

    ###### Java的泛型是如何工作的 ? 什么是类型擦除 ?
         List<String> list=new ArrayList<String>();
         List<Interger> list1=new ArrayList<Integer>():
         list.getClass==list1.getClass();两者相等，将类型信息擦除了，这就是所谓的类型擦除。
    ###### 什么是泛型中的限定通配符和非限定通配符 ?
      限定通配符有两种
      - <? extends T>类型必须是T或者他的子类；
      - <? super T> 类型必须T或者他的父类；
      非限定通配符是类型 <T> ,可用任何类型代替；

    ###### List<? extends T>和List <? super T>之间有什么区别 ?
    ###### 如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?
    ###### Java中如何使用泛型编写带有参数的类?
    ###### 你可以把List<String>传递给一个接受List<Object>参数的方法吗？
    ###### Array中可以用泛型吗?
    ###### 如何阻止Java中的类型未检查的警告?
      这种警告可以使用@SuppressWarnings("unchecked")注解来屏蔽。



    ##### 加密解密数字签名（高级如果连这个的“概念”都不知道，无法定高级）

    ###### 基与MD5或者SHA怎么做？
    - md5加密生产32位的md5码，速度非常快，性能高，安全前度比sha1低；
    - sha加密生产40位的sha码，加密速度比md5慢，性能比md5d低，安全强度比MD5高
     ** MD5和SHA1属于弱hash或者已经被破解的哈希算法。使用强哈希算法BCrypt**
     加密是单向的例如个人密码，不需要被其他人知道，所以不需要解密，如果用BASE64类似这种编码格式，就存在解码的风险，所以是建议用哈希算法这种加密方式。

    ###### BASE64是什么？和MD5的区别
      base64是常见的一种传输8字节的编码方式之一，base64是一种基于64个可以打印的字符来表示二进制数据的方法，base64编码是从二进制到字符的过程。
      md5加密是对任意长度的数据使用md5哈希算法散列为4个32位组，若格式化为ASCII字符则为16字符。若格式化16进制表示，则为32字符。

    ###### 对称和非对称加解密
    - 对称加密指的是加密和解密用的是同一个密钥，所以叫做对称加密。对称加密只有一个密钥，作为私钥。常见的对称的加密算法：
    AES ,DES,3DES等等。
    - 非对称加密指的是：加密和解密使用不同的密钥，一把作为公开的公钥，一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息只有公钥才能解密。常见的非对称加密算法：RSA,ECC
      对称加密的算法相对于非对称来说效率要高很多，但是缺陷是相对于密钥的管理上，以及在非安全的通信中，不安全。所以在实际网络中会将两者混合使用。
      例如正对C/S模型
      1.服务器计算一对密钥 pub/pri，将私钥保密，将公钥公开；
      2.客户端对服务器进行访问时拿到服务器的公钥；
      3.客户端通过AES计算出一个对称加密的密钥x.然后使用pub对x进行加密。
      4.客户端将加密后的文发送到服务端。服务端通过pri进行解密获取x;
      5.然后两边的通讯内容就通过对称加密x进行加减密。
    ###### 什么是三重DES(data entryption standard 数据加密标准 DES)
     对称的加密算法

    ###### 什么是RSA
    非对称的加密算法,公开公钥。


    ###### 扩展出什么时候用DES什么时候用RSA
      des是对称加密算法，相对于DES非对称算法来说，des算法速度处理快；DES密钥分配困难，而RSA简单，安全指数也更高。
    ###### 什么叫PBE？
    password based Entryption基于口令加密，其特点是使用口令代替了密钥，而口令由用户自己掌管，采用随机数杂凑多重加密等方法保证数据
    的安全性。
     **PBE加密流程**
      ![](static/images/pbe_encrypt.jpg)
      **PBE解密的原理图**
      ![](static/images/pbe_deEncrypt.jpg)
    ###### 常用的PBE有哪些？
    - PBEWithSHAAndDES
    - PBEWithSHAAndBlowfish
    - PBEWithSHAAnd128BitRC4
    - PBEWithSHAAndIDEA-CBC
    - PBEWithSHAAnd3-KeyTripleDES-CBC


    ###### 加密中的盐是什么用的？
     加盐加密是一种对系统登录口令的加密方式，它实现的方式是将每一个口令同一个叫做“盐”的随机数进行关联。

    ###### SecureRandom干什么用的？可以代替盐吗？
        这个类提供加密的强随机数生成器。收集了一些随机事件，比如鼠标点击，键盘点击等待，使用这些随机事件作为种子。这意味着，种子是不可预测的。不想random是默认使用系统
        当前时间作为毫秒数作为种子，有规律可寻。


    ###### 什么叫数字签名？
      数字签名能验证信息的完整性。数字签名是一个加密的过程，数字签名验证是一个解密的过程。
      数字签名是对非对称加密算法和数字摘要的技术的应用。

    ###### 我要做一个CA认证要做哪些工作 (PKI知识点）

    ##### String你用过吗？

    ###### 那StringBuffer用过吗？

    ###### String和StringBuffer的区别


    ###### 那StringBuilder用过吗？
     线程安全

    ###### 什么是可变类，什么是不可变类？（String不可变StringBuffer可变）
    final


    ###### 如果我要自己写一个类，使其不可变，这个类该怎么写，不用告诉我代码就告诉我一下这个类长什么样吧！
    final，定义常量，值不可变。



    ###### StringBuffer和StringBuilder的区别
    - 在运行速度来讲StringBuilder>StringBuffer>String;
    - StringBulider是线程非安全的，StringBuffer是线程安全的里面带有synchronize关键字。


    ##### 序列化是作什么用的？
    简单来说就是为了保存内存中的各种对象的状态，并且可以把保存的对象再度读出来。用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化（i/o），

     ###### 一定要序列化吗？如果不序列化会有什么后果？
    一般需要序列化的情况：
    - 当你想把内存的 对象保存到一个文件 fileOutputStream或者数据库中；
    - 当你想用套接字在网络中传送对象的时候；
    - 当你想通过RMI传输对象的时候；


     ###### serialVersionUID的作用
    用于java序列化的机制。简单来说java的序列化机制是通过判断类的serialversionUID来验证一致性，jvm会把传来的字节流中的
    serialVersionUUID与本地的实体类的进行比较，如果一致，可以进行反序列化，否则就会出现序列化版本不一致的异常。

     ###### 如何生成serialVersionUID？随机还是1L，区别呢？
    随机的好处是：Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，
    然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。


    ##### 书写代码时hashcode和equals有没有覆写过？

     ###### 我有一个类，Peson，内含2个字段，String name, int age，请问我的hashcode方法在覆盖时该怎么写？


     ###### 为什么我们在定义hashcode时如： h = 31*h + val[off++]; 要使用31这个数呢？我可以用100这个数吗？和用31有什么区别吗？


     ###### 如何equals相等hashcode是否一定相等
      如果两个对象判断equals相等，那么hashcode值也相等，如果两个对象equals不相等，hashCode也不一定不相等。
       hashCODE在哈希表中起作用，例如hashset,hashmap等。通过hashcode方法来计算哈希码，通过哈希吗可以直接定位object在hash表中的 位置
       如果该位置没有对象可以插入到该位置，如果该位置有对象，可能有多个，则调用equals方法比较这些对象与object是否相等，如果相等，则不需要保存object
       如果不相等，将该对象加入到链表中。这就解释了equals相等，那么hashcode一定相等。
     ###### 如果equals不等hashcode是否也不等？


     ###### 如果hashcode相等equals是否一定相等？


    ##### 在Java里我们创建一个对象可以用new object，除了new外，还有几种创建对象的方法？
     可以通过注解反射的原理创建对象，或者用克隆的方式
       Object  a=new Object(); b=a;这个是负责的引用，指向同一个对象，不是克隆
       Object a=new Object();
       b=a.clone;
    ###### 至少回答出反射和克隆，要不然不算高级

    ##### Java的类反射用过吗？
    ###### 有一个类，内部有一个字段是private int age=0，我想通过反射通过外部代码改变这个age的值，应该怎么做？


    ###### 如果侯选人一直用的是CGLIB或者AOP没用过反射也可以，那么就问：


    ##### 在JDK中如何自写写一个AOP？它implements了哪个？需要实现自己AOP方法的那个覆写方法名是什么？这个方法里有几个参数，分别是作什么用的？


    ##### String.toString()和Stirng.valueOf的区别！
    - String.toString 转换为string,要求转换的内容不能为空；
    - String.valueOf()将值转换为string，不过当为空的时候不会报空指针异常，当对象为null的时候会转换为"null"；


    ###### indexOf怎么用？indexOf(Str)和indexOf(char)的区别？
    - 性能，indexOf(char)JDK内部用的是转成int来查找ascii码表的。
     indexof（str）指出string对象在字符串的开始位置，下标位置。没有则返回-1；

    ###### 我要在String helloworld中把所有的o替换成阿拉伯数字0，用什么函数？-这边问到replace和replaceAll的区别。


    ##### 一个字符串是否等于ok也可以等于Ok也可以等于oK也可以等于OK，怎么写？


    ##### System.out.println大家都会用，System.in有哪些用法？举例！


    ##### java判断某个文件后缀名为.jar该怎么做？


    ##### InputStream和BufferedInputStream区别？


    ##### java中volatile关键字的含义


    ###### 如果回答出了，可以继续问：


    ###### volatile 变量在各个线程中是一致的,所以基于 volatile 变量的运算是线程安全的这句话是对的还是错的？为什么？
    不是，非线程按照，用volatile修饰的变量只不过是对内存可见，但是在读取，修改，提交非原子性操作，所以说运算是线程安全的是错误的。


    ###### 线程中设public volatile int inc = 0; 内含一方法：public void increase() { inc++; } 启动10个线程，每个线程执行1000次increase()，最后执行完后打印一下这个inc的值，发觉不是10,000，为什么？
            虽然说volatile能保证可见性，但是 从读，+1，写非原子性，所以会出现最后的结果不一致，可以在increase方法上面添加synchronize或者在inc++添加tryLock

        public class Test {
            public  int inc = 0;
            Lock lock = new ReentrantLock();

            public  void increase() {
                lock.lock();
                try {
                    inc++;
                } finally{
                    lock.unlock();
                }
            }

            public static void main(String[] args) {
                final Test test = new Test();
                for(int i=0;i<10;i++){
                    new Thread(){
                        public void run() {
                            for(int j=0;j<1000;j++)
                                test.increase();
                        };
                    }.start();
                }

                while(Thread.activeCount()>1)  //保证前面的线程都执行完
                    Thread.yield();
                System.out.println(test.inc);
            }
        }
    ##### JAVA的GC是什么？
    垃圾回收器

     ###### 什么是新生代老年代？
     java堆中是jvm管理的最大的一块内存空间，主要存放对象实例。在堆中分为两块区域：新生代和老年代 。堆=新生代（1/3）+老年代（2/3）
     新生代=eden(8/10)+from Survivor(1/10)+to survivor(1/10),新生代这样划分是为了管理堆内存中的对象，方便GC算法，复制算法来进行垃圾回收。
    ** 新生代几乎是所有的java对象出生的地方，java对象申请的内存和存放都是在这个地方。**
    - 新生代gc(minor gc)：当对象在Eden（其中包括了一个survivor，例如from），当此对象经过一次minor gc 仍然存活，并且能被另外一块 servivor所容纳（to  survivor）
     则将这些仍然存活的对象复制到 to survivor区域中，然后清理掉 eden 和from  survivor区域，并将这些存活的对象年龄+1，以后对象在survivor中熬过一次gc则增加1，当年龄值达到默认值
    （默认值为15），这些对象就回成为老年代！但是也不一定，当一些较大的对象（需要分配连续的内存空间）则直接进入老年代。当老年代满了，就会报OutofMemory异常。
    - 老年代 gc(major gc):发生在老年代的gc,所采用的是标记-整理算法。
    老年代几乎都熬过了survivor，他们不是那么容易“死掉”，因此major  gc 不会像minor gc那要频繁。



     ###### 新生代老年代的比例我要分配一般怎么分配，官方推荐的比例是什么样的？
       堆内存=新生代1/3+老年代2/3；

     ###### 为什么你要这样设置新生代老年代的比例？依据？理由？
       因为新生代的gc频繁，将新生代转换为老年代 ，major gc不想minor gc那么频繁。

     ###### 新生代里一般有几个空间？它们分别是哪些？作用？-此处考伊甸园和幸存者空间
          新生代=eden(伊甸园 8/10) +from survivor（幸存者空间 1/10）+ to survivor(幸存者空间 1/10 存活的对象 当达到默认值的时候转换为老年代身份)

     ###### PermGen space是什么？它里面放什么东西？设置多少合理？
    内存的永久的保存空间，该区域主要被jvm存放类信息和常量静态的信息，当class被加载loader的时候就回被储存到该内存中，与
    存放类的实例的heap区域不同，java中的GC不会再主程序运行期间对PemGen  space进行清理。
    1.当我们的运用中有很多的class 很可能出现PemGen space错误
    2.我们的tomcat在重启的时候，不是使用./bin/shutdown.sh而是使用kill -9 xxx直接杀掉，这样的话，存放的
    pemGen space里面的内存空间就不会被释放，这样长时间的kill之后，就会导致系统的内存被渐渐吃完了，知道最后tomcat报错。
    pemGen space内存空间在windows里面一般去tomcat里面的/bin/catalina.bat文件里面设置在linux里面
    去tomcat里面的/bin/catalina.sh里面设置
    ** set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128m -XX:MaxPermSize=512m **

     ###### GC和FULL GC的区别
      GC:分新生代和老年代 gc；
      FULL  GC是清理整个堆空间，包括了新生代和老年代

     ###### Minor GC后，Eden是空的吗？
        minor gc新生代垃圾回收后，正常情况下Eden是空的，不过如果非正常情况下，老年代内存空间不足或者说没有内存空间，就会发生原本在eden里面的对象还是存放到Eden里面，不会晋升会老年代。

     ###### GC里的收集器有几种？分别是做什么用的？
     java有四种垃圾回收器
     - 串行垃圾回收器（Serial Garbage  collector）:串行垃圾回收器通过持有应用程序的所有线程进行工作。它为单线程环境设计，只是用一个单独的线程进行垃圾回收器，通过冻结所有应用程序进行工作，所以不适合服务器环境，他最适合的是简单的命令行程序。
     - 并行垃圾回收器（Parallel Garbage collector）：他是jvm默认的垃圾回收器。与串行不同的是，他使用多线程进行垃圾回收，相似的是他也会冻结所有的应用程序进行垃圾回收。
     - 并行标记扫描垃圾回收器（CMS garbage collector）：并发标记垃圾回收使用多线程进行扫描堆内存，标记需要清理的实例，并且清理被标记的过的实例。并发标记垃圾回收器只会在下面两种情况下持有应用程序的所有线程
             1.当标记的引用对象在tenured区域；
             2.在进行垃圾回收的时候，堆内存的数据被并发的改变。
       相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序分配更多的CPU，那么并发标记扫描垃圾回收器是更好的选择比并发垃圾回收器。
             通过JVM参数 XX:+UseParNewGC打开并发标记扫描垃圾回收器。

     - G1垃圾回收器（G1 garbage collector）：适用堆内存很大的情况下，他将堆内存分隔成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后，
     对剩余的堆内存空间进行压缩。并发标记扫描垃圾回收器在STW情况下压缩内存。G1垃圾回收器会优先选择第一块垃圾最多的区域
           通过jvm参数 -XX:+UseG1GC使用G1垃圾回收器。
     ![](static/images/garbageCollector.jpg)


     ##### 内部类的作用是什么？
     -  1.内部类可以实现很好的隐藏；
     - 2.内部类拥有外围类的所有的元素访问权限。内部类可以访问这个类的外围类的所有元素，包含私有属性。
     - 3.可以实现多重继承：在一个外围类里面写多个内部类，分别继承不同的类，那么这个外围类就等于间接继承了多个类。
     - 4.可以避免修改接口而实现同一个类中两种同名方法的调用。当一个类继承和实现一个接口，类和接口都有同一个方法名，那个方法被重载，这个就不好区别了，这样我们可以通过内部类，外围类继承一个类，内部类实现接口。


    ###### 静态内部类是什么？它有什么局限？
        如果定义为静态内部类就不能调用外围非静态的成员变量。

    ###### 私有内部类是什么？它有什么局限？
     局限性 ：只会被外围的类调用，不能被其他类调用


    ###### 嵌套内部类是什么？它有什么局限？
         定义到一个方法或者一个作用域的类，局部内部类的访问权限限于该方法或者作用域内。

    ###### 匿名内部类是什么？它有什么局限？
    匿名内部类是唯一一种没有构造器的类，一般用来继承或者实现其他接口，并不需要添加额外的方法，只是对继承方法的实现或者重写。


    ##### java的克隆是做什么用的？
    克隆一个对象，将被克隆对象的属性赋予给这个克隆对象。


    ###### 什么是深克隆、什么是浅克隆？
    - 浅克隆是指被复制对象的所有变量都含有与原来的对象相同的值，而所有对其他对象的引用仍然指向原来的对象（这种就类似复制的作用）。
    - 深克隆 被复制的对象的所欲变量都含有与原来对象相同的值，并且引用其他的对象的变量指向被复制过的新对象（序列化等同于深克隆）。


    ###### 如果一个类，类中套类再套类，套了好几层，有什么办法在不用第三方工具的情况下对这个类进行深克隆
    （使用序列化和反序列化可以做到）


    ##### 算法
    ###### 冒泡排序
    ######穷举

    ###### 二分

    ###### 说有一数组int[]{1,2,2,4,6,8,9,5,3,7,5}，里面可能还有很多，想要知道”两两相加等于10“的这样的数有几对，可以重复如：2+6，6+2，描述一下你准备怎么做即可，不用代码？

    1.先对数组进行排序；
    2.然后进行收尾相加，依次递归，判断相等情况。
    ###### 使用冒泡法的说平时不注重算法
    ###### 使用二分法的为高级


    ###### 说有一个ArrayList{1,2,3,5,1,2,7,5,3,3,4,5,6,9,11,11}，它里面有许多重复数，我要求去除所有的重复数据，得到一个不重复的List。
      1.创建一个新的数组，如果值相等的情况下，不往新数组放，另外将重复的下标 ，第一个往数组里面放
      2.创建hashmap的特性来实现。

    ##### 数组有没有length()这个方法?String有没有length()这个方法
    有这个方法，可以求字符串里面的长度；

    ##### error和exception有什么区别?
    - error是系统里面错误，程序员是不能改变和处理的，是在程序编译时出现的错误，不可控的。
    - exception是可以控制的，应该在应用程序级别被处理，
    exception分为两类：编译时异常（CheckedExcption）:例如说io里面的异常；
    运行时异常（unCheckedException   -- runTimeException）:illegalArgumentException,nullPointerExcetion,indexOutofBoundsException

    ##### Jvm中类加载的流程?
    - 加载类
    - 连接（验证，准备和解析）验证类加载的正确性，为类型分配内存和赋予初始值，为字符引用解析为直接引用；
    - 初始化：为初始化指定到指定值。
    ![](static/images/jvm_classload.png)

    ##### 什么是双亲委派模型? 优点是什么?
    jvm 类加载的机制----双亲委派模型。这个模型要求除了bootStrap classloader外，其余的类类加载器都要有自己的父加载器，子加载器通过组合来服用父
    加载器的代码，而不是使用继承。在某个类加载器加载class文件时候，它首先委派父加载器去加载这个类，
    依次传递到顶层加载器bootstrap ，如果顶层加载不了，子加载器才会尝试加载这个类。
    ![](static/images/parentsDelegationModel.png)
    **双亲委派模型最大的好处是让java类同其类加载器一起具备了一种带优先级的层次关系。例如说我们要加载一个object类，这个加载请求最终会被bootstrap去加载，这样就保证了所有加载object的类都是同一个类，不会出现各种
    不同的类去加载，因为不同的类去加载那么他们就不相等了。**


    ##### 强引用，弱引用，软引用，虚引用。
    强引用：只要引用存在，GC永远不会回收。Object obj=new Object();
    软引用：非必须引用，在内存溢出之前进行回收。
    弱引用：在第二次GC回收时回收。通过弱引用的数据 在短时间内可以取得数据，我们可以通过查询isEnQueued()查看对象是否本地垃圾回收标记。
    虚引用：垃圾回收时回收，无法通过引用取得对象值。
    内存存在时间： 强>软>弱>虚引用

    ##### js跨域方法
    - jsonp(我们直接用xmlHttpRequest请求不同域上的数据时，是不可以的，当时在页面引用不同域的js脚本，文件却是可以，jsonp就 是利用这个特性来实现的)
    - 通过修改document.domain来跨子域，浏览器都有一个同源策略，其限制之一就是方法一种我们说的不能通过ajax的方法请求不同的源的文件。第二个限制是浏览器中的不同域的框架之间
    是不能进行js交互操作的。
     - HTML5中新引入的方法  window.postMessage方法跨域传送数据
     - 使用window.name来进行跨域传值。


    ##### mysql索引有哪几种
    在关系型数据库中，索引是一种单独的，物理的对数据库表中一列或者多列的值进行排序的一种存储结构，它 是某个表中一列或者若干列的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。
    分页：mysql自带的   SELECT * FROM table order  by id desc  LIMIT 5,10; // 检索记录行 6-15
    分页：select * from table where id>(pageNo-1)*pageSize order by Desc  limit  pageSize   利用这种方式 主要是当数据量达到千万级别的时候利用主键索引进行分页会速度更快
      eg:翻页的时候值需要小于40  ,然后每页10也，
    从结构：
        b+树，
        hash索引（其检索效率非常之高比b+数都高，不过仅仅能满足 : = ，in <=>.只有memory存储引擎显示支持hash索引）,
        fulltext索引（myisam和innodb引擎都支持了）
        R-tree索引
    从物理存储：
        聚簇索引 innodb 使用的聚簇索引&非聚簇索引 myisam不管是主键索引还是二级索引使用的都是非聚簇索引
       ！[](static/images/index.png)
        对于非聚簇索引右图 ，表数据和索引是分成两部分存储的。主键索引和二级索引存储上没有任何区别，使用b+数作为索引存储结构，所有的节点都是索引，叶子节点存储的是索引和索引对应的记录地址
        对应聚簇索引来说 左图，表数据是和主键一起存储的，主键索引的叶节点存储行数据（包含了主键值），二级索引的叶节点存储的喊的主键值，使用的b+数作为索引的存储结构，非叶子节点都是索引的关键字，单是
        非叶子节点中的关键字中不存储对应的记录的内容或者内容地址。叶子节点上的数据是主键和具体记录

    从逻辑结构：
         普通索引或单列索引，唯一索引，主键索引，组合索引，全文索引

    **如何选择索引列**
    - 性能优化的过程中，选择在哪个列创建索引，可以考虑索引主要有两种类型的列：where字句中出现的列，在join字句中出现的列
    - 考虑列中的值的分布，索引的列的基数越大，索引效果越好
    - 使用短索引，如果对字符串进行索引，应该制定一个前缀长度，可节省大量的索引空间，提升查询效率
    - 利用最左前缀
    - 不要过度索引
    为什么不建议创建太多的索引，因为每个额外的索引都要占用额外的磁盘空间，并降低些性能。在修改表内容时，索引必须进行更新，有时树可能需要重构，因此索引越多，耗时越多。
     mysql只对一下操作符才使用索引：< <= =,> ,>=,between,in.以及某些时候的like（不以通配符%或_开头的情形）

    ##### redis 为什么能作为缓存
    - redis中，并不是所有的数据都一直存储到内存中，这是和memcache相比一个最大的区别
    - redis在很多方面具备了数据库的特征，或者说就是一个数据库系统。而memcache值是简单存储K.V缓存
    - 可以扩展做集群:master-slave,hash
    - 不过相比memcache在100k以上，memcache性能要高于redis
    - 就内存使用效率来说，使用简单的key-value存储的话，memcache的内存利用率更高，而如果redis采用hash结构做key-value
    存储，由于其组合是的压缩，其内存利用率会高于memcache。
    - 如果对数据持久化和数据同步有所要求，那么使用redis会更好，因为memcache不具备这个功能
    - redis支持多种数据结构 string，list（链表） ，set（结合）  ,dirc  zset（有序结合）,hyperloglog   key-value
       key 存储唯一表示符，value  存储对象 ，存储map。。。
    - 支持pub-sub消息订阅机制，可以同时进行消息订阅与通知

    ##### spring  事务
    事务具有:原子性，一致性，隔离性，持久性 （银行转账）
    spring 并不是直接管理事务，而是提供了多种事务管理器。将事务管理职责委托给hibernate或者jdbc,JPA 进行管理
    spring的事务管理接口是 org.springframwork.transaction.platformTransactionManager 包含了 getTransaction,commit,rollback方法
    - jdbc事务
      <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dataSource" />
        </bean>
    - hibernate
    <bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">
            <property name="sessionFactory" ref="sessionFactory" />
        </bean>
    - JAVA持久化API事务（JPA）
    <bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
            <property name="sessionFactory" ref="sessionFactory" />
     </bean>


     - JAVA原生API事务-jta
     <bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager">
             <property name="transactionManagerName" value="java:/TransactionManager" />
        </bean>

  **事务传播行为**
  - propagation_require  当前事务存在就在当前事务运行，没有事务创建新的事务
  - propagation_supports 当前方法不需要事务上下文，如果存在当前事务，就在该事务中运用
  - propagation_mandatory  表示必须在事务中运行，如果没有事务抛出异常
  - propagation_required_new 表示当前方法必须运行在自己的事务中，一个新事务将别启动，如果当前有事务将会被挂起，
  - propagation_not_support 表示该方法不需要运行在事务中，如果当前有事务需要被挂起
  - propagation_never 当前方法不应该运行在事务上下文中，如果有事务会抛出异常
  - propagation_nested 表示如果当前已经存在一个事务了，那么就回嵌套在事务中运行。嵌套的事务可以独立于当前的事务进行提交或者回滚。如果当前事务不存在，那么他的行为和propagation_required一样

    ##### spring dispatcherServlet 工程流程
    - 在tomcat启动，对dispatcherSevlet进行实例化，然后调用它的init方法进行初始化，
    初始化过程完成后，对web.xml中的初始化参数的加载；建立webapplicationContext(springmvc 的ioc容器) ；进行组件的初始化；
    - 当客户端发送请求，tomcat接收到这个请求，去匹配dispatcherSerlet在web.xml里面的隐射路径，tomcat将请求转给dispatcherServlet处理
    - dispatcherServlet从容器取出handlerMapper实例（每一个实例对应一个handleMapping接口实现类）并遍历，每个
      handleMapping会根据请求信息，通过自己实现类中的方法去找处理该请求的handle（执行程序，如controller里面的方法），并将这个handle与一堆的handleInterceptor封装成一个handleExecutionChain对象，一旦handleMapping
      可以找到一个handle就退出循环；（getHandler,获取页面处理器，通俗点就是获取由哪个Controller来执行，包含方法信息以及方法参数等信息）
   - dispatcherServlet取出handleAdapter组件，根据找到的handle，从handleAdapter中可以找到处理该handle的HandleAdapter对象（ 负责真实的页面处理器进行处理并返回modelAndView，handleAdapter有一些常见的处理，比如消息转移，参数处理等。）

   ##### Spring的ioc与aop
   ##### zookeeper工作原理

    ##### 抽象类与接口的区别
    - 抽象类可以有默认的方法，接口完全是抽象的方法名没有方法体
    - 抽象类是使用extends继承，接口是通过implement进行实现
    - 抽象类可以有构造器，接口无构造器
    - 抽象方法的修饰符可以有public protected和default修饰符，接口只能有public修饰符，
    - 抽象类相比普通类的唯一区别就是不能进行实例化，接口是完全不同的类型
    - 抽象类可以继承一个类 实现多个接口； 接口只能继承一个或者多个其他接口
    - 抽象类比接口速度更快，接口是稍微会有点慢，因为它需要时间去虚招在勒种实现的方法。
    - 抽象类里面添加新方法，可以提供默认的实现，就不需要改变现有的代码。如果是接口添加方法，就必须改变该接口的实现类了
     ###### 抽象类为什么不能实例化
     因为java中程序中都有一段代码段，占据一定内存，抽象类里面有未实现的方法存，无法具体分配内存空间，所以为了安全，接口和抽象类都不能直接实例化

    #####  HTTP与HTTPS的区别
    http: hyper text transfer protocol 超文本传输协议
   - https具有安全性的ssl加密传输协议，需要到Ca申请证书，它的传输可进行加密传输，身份认证和网络协议。http是明文传输。所以HTTPS更安全
   - http连接简单，是无状态的。
   - http与HTTP是 的使用两种完全不同的连接方式，端口号也不一样，前者是80，后者是443；
   - HTTPS之间的通讯都是加密的，利用非对称RSA算法进行密钥交换。

    ##### 单点登录(single sign on)有哪几种方式
    **一个项目中有多个系统，子系统，避免在每个系统里面都进行登录，我们可以通过单点登录解决这个问题**
    浏览器第一次请求对象，服务器创建一个会话，并将会话id作为相应的一部分传递给浏览器，浏览器会存储会话id,并在后续的第二次，第三次与服务器取得请求中的带上这个会话id，这样
    服务器取得请求中的会话id就知道是不是同一个用户了。
    ![](static/images/session.png)

    服务器在内存中保存会话对象。浏览器保存会话id两种方法。
    1.请求参数
    2.cookie: cookie是浏览器用来存储少量数据的一种，数据以key-value形式存储，浏览器发送http发送请求的时候浏览器自动发送会话id.
    cookie机制证号用来做这件事。

   tomcat会话机制当然也实现了cookie，访问tomcat服务器时候，浏览器可以看到一个名为jessionid的cookie，这就是tomcat的会话机制。
   流程如下：
   - 第一次请求到服务器
   - tomcat服务器创建会话，第一次响应浏览器 （JSESSIONID）；
   - 浏览器设置cookie(JSESSIONID),发送第二次请求（http请求带上cookie：JESSIONID）,服务器第二次响应;
   - 第三次同第二次一样；

   **判断登录状态**
   - 有了会话机制。登录状态就容易了，假设第一次登录请求服务器的时候需要输入用户名和敏，判断这个持有这个会话的合法性，
   应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话状态，就保存到会话对象中。
   - 所以第一次登录 添加登录状态：
   HttpSession session = request.getSession();
   session.setAttribute("isLogin", true);
  -  再次登录访问的时候，tomcat会在会话对象中查看登录状态：
   HttpSession session = request.getSession();
   session.getAttribute("isLogin");
   每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。

   单系统登录解决的核心是cookie，单是多个系统之间因为cookie的不能跨域的限制，导致在跨域请求中http请求不携带cookie。

   单点登录跨系统要点如图：
       ![](static/images/sso.png)
   - 用户访问系统1的受保护资源，系统1发现用户未登录，跳转到sso认证中心，并将自己的地址作为参数
   - sso用户中心发现用户是未登录的，将用户引导到登录页面；
   - 用户输入用户名，密码提交登录申请
   - sso用户中心校验用户信息，创建用户与sso认证中心的会话，称为全局会话，同时创建授权令牌；
   - sso认证中心带着令牌跳转到最初的请求地址（系统1）；
   - 系统1拿到令牌，去sso认证中心验证令牌是否有效；
   - sso认证中心验证令牌，返回有效，注册系统1；
   - 系统1使用令牌创建与用户的会话，称之为局部会话，返回受保护的资源；
   - 用户访问系统2的受保护的资源；
   - 系统2发现用户为登录，调整至sso认证中心，并将自己的地址作为参数；
   - sso认证中心发现用户已经登录，跳转回系统2地址，并附带令牌；
   - 系统2拿到令牌，去sso认证中心验证令牌的有效性
   - sso认证中心验证令牌，返回有效，注册系统2；
   - 系统2使用该令牌创建与用户的局部会话，返回受保护的资源。

###### sso单点登录实现
　　只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）
  　
   sso-client
    1.拦截子系统未登录用户请求，跳转至sso认证中心
    2.接收并存储sso认证中心发送的令牌
    3.与sso-server通信，校验令牌的有效性
    4.建立局部会话
    5.拦截用户注销请求，向sso认证中心发送注销请求
    6.接收sso认证中心发出的注销请求，销毁局部会话
　　
    sso-server
    1.验证用户的登录信息
    2.创建全局会话
    3.创建授权令牌
    4.与sso-client通信发送令牌
    5.校验sso-client令牌有效性
    6.系统注册
    7.接收sso-client注销请求，注销所有会话

    ##### 数据结构
     最优算法 堆（最大堆，最小堆） 最小堆根节点是最小的。关于如何遍历，怎么维持树的平衡。

    ######  常见的数据结构 collection《list ,set 继承了collection》和map
    【 集合 collection常用的方法 add,remove ,contains,iterator,size:
     list 有序可重复 常用get获取元素,
     set无序，唯一
     map双列结果 map结合的数据结构仅仅正对键有效，与值无关； 存储的是键值对形式的元素，键唯一，值可重复
     map常用的方法 有put,remove ,containskey,containsValue()，keyset,get,value,entrySet,size
     】
     - arrayList（list） 底层的数据结构是数组，查询快 ，增删满；  线程不安全 ，效率高；
     - vector(list)  层次结构是数组，查询快，增删满； 线程安全，效率低；
     - linkedlist(list)  底层结构是链表，查询慢，增删快； 线程不安全，效率高；
     - hashSet(set) 底层结构是哈希表，哈希表依赖两个方法 hashCode(),equals()
        执行顺序：首先判断hashcode是否相等：当相等的时候判断equals()是否相等 ，当相等的时候说明已经有重复元素不能添加，否则能添加
           最终，自动生成hashcode()与equeal()即可
     - linkedHashSet(set):底层结构是链表和哈希表组成，由链表保证元素有序，由哈希表保证元素唯一；
     - treeSet（set）:数据结构是红黑树（是一种自平衡的二叉树）；他保证元素的唯一性是根据返回值是否为0决定；
        保证元素排序：自然排序（元素具备比较性）让元素所属的类实现comparable接口
                    比较器排序（集合具备比较性）：让集合接受一个comparator的实现类对象
     - hashmap：底层是哈希表，线程不安全，效率高，哈希表依赖equals和hashcode；
     - linkedHashMap ：底层由链表保证元素的有序，由哈希表保证元素的唯一；
     - hashtable:底层的数据结构是哈希表，线程安全，效率低。依赖hashcode和equals来决定
     - treemap 底层数据结构是红黑树
     ** arraylist默认长度为10 ，hashmap默认长度是16**

    ######   程序=算法+数据结构
      数据结构是计算机的存储，组织数据的方式
      数据结构是指相互之间存在一种或者多种特定关系的数据元素集合
      通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率
      数据结构往往同高效的检索算法和索引技术相关。

    ######   ** 常见的数据结构**
      集合：set multiset
      线性结构：数组，队列，链表，栈
      树形结构：二叉树及其变型，线段数，
      图形结构：各种图

    ######  **堆也被称为优先队列，因为他的操作也是先进先出，从对位插入原始，在队头取出元素。
      而堆是在堆底部插入原始在堆顶取出元素，不过堆不是按照先后来的顺序，而是按照优先顺序排列的。小的元素排在后面是最大堆，最大的元素在顶端 根节点； 最小堆顶部是最小的元素，最大的元素是排在后面的。堆可以看作一个二叉树。用二叉树来表示堆；
       单是因为堆里面的元素是按照一定的优先顺序进行排列的，我们可以用更简单的方法“数组”来表示，这样可以节省子节点指针空间，
       并且可以访问美国节点，堆的数组表示其实堆层级遍历的结构**
    ###### 反转单向链表

     ##### 做微服务主要是做资源隔离（不同的压力部署的服务数不同； 线程隔离 避免访问数多的占用完线程池，别的产品访问量少的没有线程可用）

     #####  系统之间交互的方式
      - 通过rest ,websevice之间进行访问
      - 通过kafka ，rabbit mq进行交互
      - 通过dubbo 分布式这种访问方式
     ##### 中间件安装方式
      - 单机模式
      - 主从集群（当请求量不是上万级别的用一个从服务器保证数据的安全性就可以了，没必要做分布式集群增加维护成本）
      - 分布式集群（分布式集群在考虑分布式事务管理会比较麻烦，成本稍微高）

     ##### UML建模
      Visio建模工具

      ##### keepalived

      ##### docker+jekins
      部署jekins涉及的参数：
      - 组织结构
      - 部署环境 env
      - 项目名称 appName
      - 项目发布的访问地址   app_address
      - codeTarget code target地址
      - buildcmd 构建项目所需的参数，环境
      - fromImage 上层镜像
      - toImage 目标镜像
      - runOptions 运行环境参数
      - git 库地址
      - docker_registry  docker服务器在国外，服务会比较慢，所以会建立自己的私库

      ##### OOA/OOD
        ###### OOA  object-oriented analysis：面向对象分析法 ，指的是一个系统在开发过程中业务系统调查过后，按照面对对象的思想来分析问题。OOA所强调的是在系统调查资料的基础上，针对oo方法所需要的素材进行的归类
       分析和整理，而不是管理约我现状和方法的分析。它的模型是由五个层次（主题层，对象类层，结构层，属性层和服务层）和5个活动（标示对象类，
       标识结构，定义主题，定义属性和定义服务）组成。
       主要优点是：
       1. 加强对问题域和系统责任的理解。
       2.改进与分析有关的各类人员之间的交流
       3.对需求的变化具有较强的适应性
       4.支持软件的复用
       5.贯穿软件声明周期全过程的一致性
       6.实用性
       7.有利于用户参与
       ######  OOA方法的具体步骤
       1.确定对象和类
       2.确定结构
       3.确定主题
       4.确定属性
       5.确定方法
  ###### OOD  object-oriented Design 面向对象设计
   OOD步骤
   1.细化重组类
   2.细化和实现类之间的关系，明确其可见性
   3.增加属性，指定属性的类型与可见性
   4.分配职责，定义执行每个职责的方法
   5.对消息驱动的系统，明确消息传递的方式
   6.画出详细的类图和时序图


 ###### OOP  object-oriented Program 面向对象编程



 ##### 分布式如何进行分布式事务管理
 1.ebay模式：通过消息日志方式来异步处理。消息日志可以存储到本地文本，数据库或者消息队列，再通过业务规则自动或者人工发起重试。人工重试更多的应用于支付场景，通过对账系统事后问题处理。
 - 通过本地数据库的事务保障，增加了transactions表及消息队列。
 - 分别读出消息队列（但不删除），通过判断更新的记录来检查相关记录是否被执行，未被执行则会修改用户表进行标记，另外增加一条修改记录到记录表里面。直到事务执行成功后删除队里。这个就达到了最终的一致性。
 2. 分布式事务的两种解决方式(去哪儿网)：
   **优先使用异步消息--异步消息consumer端需要实现幂等。**
         幂等有两种方式 a:通过业务逻辑保证幂等，如果接到支付成功的消息订单状态变为订单完成，如果当前状态是支付完成，则在收到一个支付成功的消息则说明消息重复了，直接作为消息成功处理。
         b:当业务无法保证幂等，则要增加一个去重或者类似的实现。对应producer端在业务数据库的同实例上放一个消息库，发消息和业务操作在同一个本地事务李，。发消息的时候消息不立即发送，而是向消息库插入一条记录，然后再事务提交的时候再异步将消息发送，
         消息发送成功，则删除，如果因为网络或者消息队列异常的问题，消息没有发送成功，那么消息就留在这里了。会有另外一个服务不断地将这些消息扫出重新发送
     **不适合异步消息的方式，需要同步得到结果**
     例如购物去库存，当A 购买成功，c执行成功，但是b是扣除库存没有执行成功，那么重试直到执行成功。将行为记录本地事务状态上面，如果b执行成功，但是现在已经没有库存可扣除了，那么就回回滚A和c

 ##### redis 分布式锁实现原理

 ##### lock的底层原理

 ##### 阻塞队列
       wait(等待，非阻塞) notify（释放资源）


 ##### UDP与TCP区别
 - TCP是面向连接的(例如说打电话需要拨号建立连接)，udp是无连接的，例如说发送短信就不需要建立连接
 - tcp提供可靠服务，通过tcp连接传送的数据，无差错，不丢失，不重复，并且按序到达；udp按最大努力交付，不保证可靠交付；
 - udp具有较好的实时性，工作效率比tcp高，适用于对实时和高速传送的通信和广播通讯；
 - 每条tcp连接只能是点到点；udp支持一对一，一对多，多对一和多对多的交互通信；
 - tcp对资源的要求较多，udp对资源的要求少；

 tcp/ip协议需要建立三次握手方可进行通讯；
 tcp的服务器编程的一般步骤是：
 1.创建一个socket   socket socketlisten=socket();
 2.设置socket属性，setSockOpt()；可选；
 3.绑定IP地址，端口信息
 4.开启监听 listen
 5.接收客户端的连接 用函数ACCEPT;
 6.收发数据，send(),recv(),read(),write();
 7.关闭网络连接  closeSocket();
 8.关闭监听；
 TCP编程的客户端一般步骤是：
 　　1、创建一个socket，用函数socket()；
 　　2、设置socket属性，用函数setsockopt();* 可选
 　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选
 　　4、设置要连接的对方的IP地址和端口等属性；
 　　5、连接服务器，用函数connect()；
 　　6、收发数据，用函数send()和recv()，或者read()和write();
 　　7、关闭网络连接；




 ##### hession
   HESSION是一个轻量级的RPC框架（RPC 远程过程调用：有两台服务A,B分别部署到两台服务器上面，当想要调用B服务器上面那么的提供的方法或者函数，由于不在一个内存空间不能直接调用，需要借助网络进行通信）
     他是基于http传输的协议，使用hession二进制序列化，对于数据报比较大的清清裤比较友好，但是它的参数和返回值都需要实现serializable接口。

     通过配置hession ，配置hession 的service以及 hession的映射地址（和servlet类似）；
     服务端的几个步骤：
     - 编写接口和实现类；
     - 在web.xml里面配置hessionServlet，并且将上一步的实现类设置为servlet的【service-class】属性值
     - 将servlet部署到tomcat容器中。

     	<!-- 有盾服务 -->
     	<bean name="/YdService" class="org.springframework.remoting.caucho.HessianServiceExporter">
     		<property name="service" ref="ydHessianServiceImpl"></property>
     		<property name="debug" value="true"/>
     		<!-- Hessian服务的接口-->
     		<property name="serviceInterface" value="com.qf.pboc.YdService"/>
     	</bean>


    ##### 为什么在进行序列化的时候调Serializable,但是里面没有任何具体的方法，这个意义所在是什么？
    **注意事项**
    - 序列化时候，只对对象的状态近保存，而不管对象的方法；
    - 当一个父类实现序列化的时候，子类自动实现序列化，不需要显式实现serializable接口；（String 实现了serializable接口，comparable接口，charSequence接口）
    - 当一个对象的实例变量引用了其他对象，序列化改对象时也把引用对象进行序列化；
    - 并非所有的对象都可以序列化，比如：
    1.安全方面原因，比如说一个对象拥有private，public，等field，对应一个要传输的对象，比如写到一个文件或者进行rmi传输等等，在进行序列化进行传输的过程中，这个对象的private等域不受保护的。
    2.资源分配方面的原因，例如socket，thread等，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，并且也是没必要这样实现的。

       java中的序列化是以特定的方式对类实例的瞬间状态进行编码保存的一种操作。序列化的作用的对象是类的实例。对对象的实例进行序列化，就是保存
       实例当前在内存中的状态，包括实例的每一个属性的值和引用等。保存这个状态的主要作用是用于不同的jvm之间进行类实例的共享。
       在ORMaping中的缓存机制，进行缓存同步时，便是常见的java序列化应用之一，在进行远程方法调用，远程过程调用时，采用序列化对象传输也是一种应用。当你想从一个
       jvm调用另外一个jvm对象 考虑用序列化。

       反序列化作用就是将序列化后的编码成类实例的瞬间状态。申请等同的内存保存该实例；

   ###### 什么是Java对象序列化
           Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。
           使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的"状态"，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。
           除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用，在本文的后续章节中将会陆续讲到。

   ###### 默认序列化机制
   如果仅仅只是让某个类实现serializable接口，没有任何其他处理，则就是使用默认的序列化机制。使用默认的序列化机制，在序列化对象时候，
   不仅会序列化当前对象本身，还会对该对象的引用对象也进行序列化，同时这些其他对象引用的另外对象也会被序列化。以此类推
   如果易桂香包含了成员变量是容器类对象，而这个容器所含有的容器类对象，那么这个序列化的过程会比较复杂，开销也会比较大。
   ###### 影响序列化
   在现实应用中，有些时候不能使用默认序列化机制，比如说我们希望在序列化的过程中忽略敏感数据，或者简化序列化过程
   例如说关键字 transient；
   例如说当某个字段被声明用transient关键字，那么默认序列化机制就会忽略此字段（这样就不会读这个敏感字段，增加了安全性）
   ###### externalizable
   这个序列化类实现了serializable接口，另外新加了writeExternal(),readExternal()两个方法，默认这个两个方法没有写任何内容，说明不进行任何序列化操作
   ，如果重写进行你需要序列化的变量。

    ##### object 有哪些方法
     clone,wait ,notify  notifyall(),equals ,hashcode ,toString ,getClass,
     registerNative(是对几个本地方法进行注册(也就是初始化java方法映射到C的方法),JNIEXPORT void JNICALL)

     在object里面是判断两个对象是否相等 ，使用默认的“equals()”方法，等价于“==”方法。
     因此，我们通常会重写equals()方法：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。

    == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象
    equals() 1，没有被覆盖的时候equals的时候判断两个对象是否相等 ；2，被覆盖重写，判断两个对象的的内容是否相等，如果相等，就返回true；

    hashCode的作用是获取哈希码，也被称为散列码，它实际返回的是一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。
    在jdk里面有hashCode()，这意味着java中的任何类都有hashcode函数。不过只有在散列表( hashTable，hashMap,hashSet)才有用，确定该类在每个对象在散列表中的位置。
    例如说：当在一个hashSet里面插入了1000个元素，当插入第1001个元素都是时候，不是与前面1000 个元素进行对比，这样效率会很低，而是利用散列元素的特性，找到
    元素在散列表中的位置，然后将元素插入该位置即可。对于相等的元素，自然是只保存一个；
    - 所以当两个对象相等的时候，他们的hashcode（）值一定相等；
    - 但是hashcode相等的情况，他们不一定相等。

    1.对于不会创建“类对应的散列表”：我们不会再hashSet,hashTable，hashMap等这些本质就是散列表的数据结构中用到该类，
      例如说不会创建该类的hashSet集合。这种情况下hashCode和equals没有任何关系；
      如果有的对象进行比较，业务上不需要所谓比较他们的hashcode，只用比较equals（）方法

    2.会创建“类对应的散列表”：会在hashSet,hashTable,hashMap等等这些本质上面是散列表的数据结构中，用到该类。例如说会创建hashSet集合。
        这个时候该类的hashCode和equals是有一定的关系
        1）当两个对象先更的时候 他们的hashcode值一定相同；
        2）如果两个对象hashcode相等，他们不一定equals相等。
         // 新建Person对象，
             Person p1 = new Person("eee", 100);
             Person p2 = new Person("eee", 100);
             Person p3 = new Person("aaa", 200);

                 // 新建HashSet对象
              HashSet set = new HashSet();
              set.add(p1);
              set.add(p2);
              set.add(p3);
              System.out.printf("p1.equals(p2) : %s; p1(%d) p2(%d)\n", p1.equals(p2), p1.hashCode(), p2.hashCode());
             // 打印set
              System.out.printf("set:%s\n", set);

             重写 equals方法
                /**
                        * @desc 覆盖equals方法
                        */
                       @Override
                       public boolean equals(Object obj){
                           if(obj == null){
                               return false;
                           }

                           //如果是同一个对象返回true，反之返回false
                          if(this == obj){
                               return true;
                           }

                          //判断是否类型相同
                           if(this.getClass() != obj.getClass()){
                              return false;
                           }

                           Person person = (Person)obj;
                           return name.equals(person.name) && age==person.age;
                       }
                   }
        打印的内容是：p1.equals(p2) : true; p1(1169863946) p2(1690552137)
                     set:[(eee, 100), (eee, 100), (aaa, 200)]

                     hashset仍然有重复元素：这是因为p1和p2的内容相等，但是他们的hashCode不等。所以hashSet在添加p1，p2不相等

        如果我们认为name,age相等就是同一个对象，去重复，那么就重写hashcode和equals()

                     * @desc重写hashCode

                   @Override
                   public int hashCode(){
                        int nameHash =  name.toUpperCase().hashCode();
                        return nameHash ^ age;
                  }
                  这样就达到去重复元素的目的。


     ##### transient关键字
     敏感字段非序列化操作。

     ##### 怎么最快的让内存包内存溢出？
     **java的内存管理就是对象的分配和释放问题**
     - 不断创建对象，运行要用到的内存大于jvm提供的最大内存 就回导致内存溢出。尽量减少全局变量的引用，让程序使用完变量的时候释放该引用能够让垃圾回收器回收，释放资源。
     - 内存中加载的数据量过于庞大，例如说一次从数据库取出过多的数据；
     - 集合类有对对象的引用，使用完后未清空，使得jvm不能回收。（例如说list里面放入了多个对象。里面是对对象的引用，存储在栈内存，如果未清空  list.clear清空里面的对象引用，或者直接list=null将list置空同时将里面的对象引用清空）
     - 代码中存在死循环或者循环产生过多重复的对象实体；
     - 使用第三方软件的bug;
     - 启动参数内存值设定的过小；
     - 静态变量和静态方法过多（静态方法和静态变量是放在方法区里面，方法区属于持久代，不被GC回收）；

     ###### JVM调用GC情况
     - 当应用程序空闲的时候
     - 当java内存堆不足的是，会不断调用GC,
     因为这个异常是根据系统运行环境决定，无法预期它什么时候出现。根据GC的机制，程序的运行会引起系统运行环境的变化，增加GC的触发机会。
     为避免这些问题程序的设计和编写应该避免垃圾对象的内存占用和GC开销。显式调用
     system.gc()只会建议JVM在需要在内存中对垃圾进行回收，不是马上进行回收。这样不能解决内存耗费资源的局面，另外还增加了GC消耗

     java中将内存分为两种 ，一种为栈内存，一种为堆内存
     1.函数基本类型变量和对象的引用变量都是在函数的栈内存中分配；
     2.堆内存中存放的new 对象和数组(堆内存线程共享，存在线程不安全问题)；
     当定义一个变量时，java会在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉该变量所分配的内存空间；
     在堆中分配的内存是由java的jvm自动垃圾回收器来管理。
     A.堆的优势是可以动态分配内存大小，生存期也不必实现告诉编译器，因为他是在运行时动态分配内存的。缺点就是运行时分配内存，存取速度较慢；
     （一个jvm只有一个堆，所有线程共享，所以存在线程非安全问题）
     B.栈的优势是存取速度比堆快，缺点是存储在栈里面的数据大小和生存期必须是确定的无灵活性；
     (  JVM虚拟机栈就是我们常说的堆栈的栈（我们常常把内存粗略分为堆和栈），和程序计数器一样，也是线程私有的，生命周期和线程一样，每个方法被执行的时候会产生一个栈帧，
          用于存储局部变量表、动态链接、操作数、方法出口等信息。方法的执行过程就是栈帧在JVM中出栈和入栈的过程。局部变量表中存放的是各种基本数据类型，
          如boolean、byte、char、等8种，及引用类型（存放的是指向各个对象的内存地址），
          因此，它有一个特点：内存空间可以在编译期间就确定，运行期不在改变。这个内存区域会有两种可能的Java异常：StackOverFlowError和OutOfMemoryError。
      )

     提示： JVM初始分配的内存由 -Xms指定，默认是物理内存的 1/64； JVM最大分配的内存由 -Xmx指定，默认是物理内存的 1/4。
      - xss栈调整：参数有 +UseDefaultStackSize -Xss256K，表示每个线程可申请 256k的栈空间

     **方法区**
     方法去是所有线程共享的区域，用于存储已经被JVM加载的类信息，常量，静态变量等数据，一般来说，方法区属于持久带
     方法区里面有一个重要概念：运行时常量池，主要存放在变迁过程中产生的常量和引用。一般情况下常量的内存分配是在编译器就能确定，但不一定全是，
     有一些可能是在运行时也讲常量放入到常量池中，例如说strin类有个native方法intern

     另外补充一个jvm内存管理之外的一个内存区：直接内存，在jdk1.4中新加入了NIO类，引入了一种基于通道与缓冲区的IO方式，它可以使用native函数库直接分配堆外内存，就是我们所说的直接内存，这样的某些场景中会提高程序的性能。




     ###### jvm 检测工具使用
      jprofiler工具用于检测和跟踪系统（限于java开发）的性能。jprofiler可以通过实时监控系统内存使用情况，随时监视垃圾会送，线程运行状况等手灯，可以
      很好的监控jvm运行情况和性能。
      - 应用服务器内存长期不合理占用，内存经常处于高位占用，很难回收到低位；
      - 应用服务器极为不稳定，几乎每两天重启一次，有时候甚至每天启动一次；
      - 应用服务器经常做 full gc，而且时间很长，大约需要30-40秒，应用服务器做full gc的时候是不能响应客户单的交易请求的，非常影响性能。
      如果在某个时刻确实是大量使用内存导致out of memory，如果说一直居高不下这个可能是程序原因导致的内存泄漏。


      ###### jmeter
      用于压力测试和性能测试，apache jmeter用于对静态和动态的资源（文件，servlet，perl脚本，java对象，数据和查询，FTP服务器等等）的性能
      进行测试。它可以用于对服务器，网络或对象模拟房中的负载来测试他们的强度和分析不同的压力类型下的整体性能
      //TODO 进行 jmeter压力测试


     ###### 如果将对象放到那个区域，使得GC不进行回收
     方法区属于持久代，所以存放到方法去里面的类信息，常量（static final NAME='JSON'），静态变量(static age=32)等数据不会被GC;
     所以有的时候静态方法和静态变量过多也会导致内存溢出；

     在栈里面的内存不是被GC进行回收，GC只能清除堆上面分配的内存。那么在本地方法栈和栈里面的分配的内存清除就要考
     靠finalize()方法，当完成操作后进入调用内存回收，例如调用free();

     优秀的编程习惯
     - 避免在循环体里面创建对象，即使该对象占用内存不大；
     - 尽量及时使对象符合垃圾回收标准
     - 不要采用过深的继承层次；
     - 访问本地变量要优于访问类中的变量（全局变量）；

     ###### 内存泄漏
     是指你向系统申请的内存进行使用（new）,可是你使用以后不归还（delete），结果你申请的那块内存你自己不能在访问
     ，该块内存已经分配出去的内存无法再使用，随着服务器内存的不断消耗，无法使用的内存越来越多
     ，系统也不能再次将它分配给需要的程序，产生泄漏，一直下去，程序也逐渐没有内存使用，就会溢出。


   ##### http请求过程

   http请求是基于tcp的协议，需要经过三次握手才能进行通讯。这就好比一个外国人来中国迷路了，然后需要问路，他首先会问对方是否会英语，对方说yes，然后他才开始问题，
   这就和客户端与服务器进行通讯三次握手是一个道理，首先要确定协议通讯是否是通的可以进行通讯的，然后返回可以通讯，这个时候才进行通讯。
   我们可以理解为两个计算机进行通讯要靠协议（目前流程的tcp/ip协议）来实现，如果两个计算机的协议不同，那么就不能进行通讯，所以这个3次握手相当于试探一下对方是否遵循TCP/ip协议，协商完成后就可以进行通信了
   建立tcp连接，
   - 你能听到我说话吗；
   - 我能听到，你能听到我说话；
   - 我也能，那么我开始发送数据了；
   ###### 为什么http要三次握手？
   为了防止已经失效的请求报文又突然传送到服务端，因而产生错误。
   例如说“已经失效的连接的请求报文段”的发送了这样一种情况：client发送出第一个请求连接报文段并没有丢失，而是在某个问那个了节点长时间滞留，以致于延误到连接释放以后的某个时间才到达服务端，
   这本来是一个早失效的请求报文，但是server收到这个失效的请求报文段后，以为client再次发送了一个新的连接请求，于是向client发送确认报文，同意建立连接，如果没有三次握手，那么只要server发送确认报文就建立了连接，
   但是client并没有发送新的连接请求，所以不会理睬server端，也不会向server发送请求。但是server却以为新的连接已经建立了，并一直等待client发来的数据，这样server的资源就会白白浪费。

   ###### http为什么说是无连接，无状态的
   http每次连接处理完都会断开，后来为了应对每次建立tcp连接的开销，加入了connection:keep-alive;
   它的无状态是每次http请求，服务器会给我们发送数据，发送完数据后不会记录任何数据。
   缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

   在我们浏览器地址输入一个域名，然后回车，以个人理解http请求的过程：
   域名解析-》发起tcp3次握手->建立tcp连接后发起http请求-》服务器响应http请求，浏览器得到html代码-》
   浏览器解析HTML代码，并亲戚HTML代码中的资源（js,css,图片等）-》浏览器对页面进行渲染呈现给用户。
   ###### 域名解析
   - chrome浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能缓存1000条缓存），看自身的缓存中是否有请求地址的对应的条目，
   而且没有过去，如果有且没有过期则解析到此结束。
   - 如果浏览器自身的缓存里面没有找到对应的条目，那么chorme会搜索操作系统自身的DNS缓存，如果找到且没有过期那么则停止搜索域名解析到此结束。
     例如说window下面查看dns缓存内容命令：ipconfig/displaydns
   - 如果在Windows系统里面没有找到DNS缓存，那么尝试获取HOSTS文件，看看这里面有没有该域名对应的ip地址，如果有则解析成功。
   - 如果在hosts文件里面也没有找到对应的条目，那么浏览器就回发起一个DNS的系统调用，就回向本地配置的首选DNS服务器发起域名解析请求
   - 如果前面四步都没有解析成功，那么就回由操作系统查找Netbios name cache(netbios名称缓存，就存在客户端电脑中)，那这个缓存有什么内容呢，凡是最近一段时间内和我通讯成功的计算机的计算机名和ip地址，就都会缓存到里面，
   如果该名称刚好在几分钟前和我成功通讯过，那么这一步就可以解析成功；
   - 当没有解析成功，那么就会查询wins服务器（是netbios名称和ip地址对应的服务器）；
   - 解析未成功进行客户端广播查找。
   - 解析未成功，继续进行客户端读取LMHOSTS文件（与hosts文件在同一个目录下，写法也一样）
   如果上面8个步骤都没有解析成功，那么此次解析就宣告解析失败，无法与目标计算机进行通讯。

    ###### 发起tcp的3次握手
    拿到域名对应的ip地址之后user-agent（一般指浏览器 ）会以一个随机的端口（1024<端口号<65535）向服务器的web程序（
    常用的是httpd，nginx等）80端口号发起tcp连接请求，这个请求（原始的http请求经过tcp/ip4层模型的层层封包）到达服务器后（
    这中间经过各种路由器设备等，局域网内除外），进入到网卡，然后是进入到内核的tcp/ip协议栈（用于识别改连接请求，解封包，一层一层的剥开），还有可能要经过netfilter防火墙
    （属于内核的模块）的过滤，最终达到web程序，最终建立tcp、ip连接。
    1.处理net发送一个连接食堂ack=0表示确认好无效，syn=1表示这是一个连接请求或者连接接受报文，同时表示这个数据不能携带数据，seq=x表示client自己的初始序号（seq = 0 就代表这是第0号包），
    这个时候client金融syn_sent状态，表示客户端等待服务器的回复；
    2.server监听到client请求报文后，如果同意请求连接，则向client发送确认，tcp报文首部中的syn和ack都设置为1，
    ack=x+1表示器翁收到对方的下一个报文段的第一个暑假序号是x+1,同时表明x为止的所有数据都已经正确收到
    3.client收到服务器确认后还需要再次确认，同时携带需要发送server 数据，一旦收到确认之后，这个tcp连接就进入established状态，就可以发送http请求了。

    ###### 为什么http协议要基于tcp来实现
    tcp是一个端到端的可靠面向连接的协议，所以http基于传输层的tcp协议不用担心数据的传输中的各种问题。

    ###### 请求中有哪些？
    put:(webdav)上传文件（但是浏览器不支持改方法）
    get：完整请求一个资源；
    post：提交表单；
    delete（webdav）删除
    options：返回请求的资源所支持的方法的方法。
    trace:追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）

    ###### url,url,urn?
    uri(uniform resource identifier)统一资源标示符
    url(uniform resource location)统一资源定位符；eg: http://www.magedu.com/downloads/nginx-1.5.tar.gz
    urn(uniform resource name)统一资源名称
    url与urn都属于uri

    ###### chrome请求发起的http请求报文头信息
    ![](resources/static/images/requestHead.png)
    accept：标示可以接受那些类型的mime（multipurpose Internet mail  extensions 多用途互联网邮件扩展，是一个互联网标准，它扩展了电子邮件的
    标准，使其能够支持ASCII字符，二进制格式附件，等多宗格式的邮件信息。）;
    connection:keep-alive表示连接是不中断的
    accept-language:表示接受那些语言
    Accept-Encoding  这个看起来是接受那些压缩方式的文件
    cookie:每次请求都会携带cookie以方便服务器识别是否是同一个客户端；
    host:用来识别请求服务器上的那个虚拟机，比如说nginx可以定义多个虚拟主机（vhost区别不同用户权限），那这里就用来标示要访问那个虚拟主机。
    user-agent:用户带来，一般请求下是浏览器，也有其他类型，如 wget curl搜索引擎的蜘蛛等。

    ##### SOAP,SOA，REST
    1. SOA(service oriented archiecture面向服务架构)：是一种软件的设计模式，主要应用于不同应用组件之间通过某种协议来互相操作，例如典型的通信网络协议。因此
    soa是独立于任何厂家，产品，技术的。
    **SOA有两个层面的定义：**
    - 从应用角度定义：soa是一种应用框架，它着眼于日常的业务应用，并将它们划分为单独的业务功能和流程，及所谓的服务（例如dubbo对soa应用）
    - 从软件的基本原理定义： soa是一个组件模型，它将应用程序的不同功能单位（服务）通过服务之间定义良好的接口和契约联系起来。
    ***基于SOA的解决方案，soa架构可分为5层水平：*
    - 用户界面层：这些gui的最终用户或应用程序访问的应用程序/服务接口；
    - 业务流程层：在应用方面的业务用例服务；
    - 服务组件层：用来建造服务的组件，如功能库，技术库，技术接口等；
    - 操作系统：这层包含了数据模型，企业数据仓库，技术平台等；
    因为soa不依赖于任务技术，因此 soap,rpc，rest是对soa不同的实现。

    2. soap(simple object access protocol简单对象访问协议)：简单对象访问协议是一种轻量的，简单的，基于xml(标准通用语言下的一个子集)的协议
     ，它被数据成在web上交互结构化的和固化的信息。
     webservice三要素：soap,wsdl(webserviceDescriptionLanguage),UDDL(universal/description/discovery and Integration),
     soap是用来描述传递信息的格式，WSDL是用来描述如何访问具体的接口，UDDI用来管理，分发，查询webservice.
     soap可以和现存的许多因特网协议和格式结合使用。包括超文本传输协议（http）,简单的邮件传输协议（smtp）,
     多用途国际邮件扩充协议（MIME）,它还支持从消息系统到远程过程调用(RCP)等大量的应用程序，SOAP是使用基于xml的数据结构和超文本传输协议（http）的
     组合定义了一个标准的方法来使用Internet上各种不同操作环境中的分布式对象。
     **soap四个部分**
     - 封装 ：定义了一个框架，该框架描述了消息中的内容是什么，谁应当处理它以及它是可选的还是必须的；
     - 编码规则：它定义了一种序列化的机制，用于交互应用程序所定义的数据类型的实例；
     - RPC表示：它定义了用来表示远程过程调用和应答的协定；
     - 绑定：定义了一种使用底层传输协议来完成在节点间交换SOAP封装的约定；

   3. REST:表症状态转移（representional state transfer）他的核心是从资源的觉来来观察整个网络，分布在各处的资源由
     uri确定，而客户端的应用通过URI来获取资源的表征。获得这些表征致使这些应用程序转变了其状态。
     随着不断获取资源的表征，客户端应用不断地转变这其状态。
     从逻辑的角度来看，为什么为更加青睐rest而不是rpc(remote procedure call远程过程调用)，
     因为它极大的降低了我们沟通的复杂度，通过把表征为唯一的沟通方法，无需要讨论过程（添加一头牛？增加一种动物类型？给小鸡数量翻倍还是卖掉），
     我们只需要讨论表征，并且使用这个表征来达到我们要的目标，
     （轻量级别，简单易用，无需要额外的SDK,维护性和扩展性都比较好，不过它只支持http协议，使用时候需要关注http协议和网络层细节，
     而http协议比较臃肿）

    4.RCP(remote procedure call远程过程调用)它是一种通过网络从远程计算机程序请求服务，而不需要了解底层的网络技术协议。
    rpc 协议嘉定某种传输协议存在，如TCP何UDP,为了通信程序之间携带信息数据，在OSI网络模型中，RPC跨域了传输层和应用层。RPC使得开发包括
    网络分布式多程序在内的应用程序更加容易。
    RPC采用了客户机/服务器模式，请求程序是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程。然后等待应答信息。在服务器端。进程保持睡眠状态
    知道调用信息到达位置，当一个调用信息达到，服务器获得进行参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接受打发信息，获得进程结果，然后调用执行继续进行。
    （RPC屏蔽了网络细节，易用，和本地调用类似，提供了灵活的api，支持多种协议；不过它比较麻烦在于使用前需要先写一个DSL描述文件，
    维护性查，当某些model类需要修改的时候，必须重新定义编译，做一些繁琐和重复的工作；
    最大的问题是不能快速的响应api升级，需要给客户端提供新的SDK,当客户端较多的时候，每加一个接口时候都需要更新一堆SDK）
    dubbo就是一种RPC框架，
    - 被远程调用的接口，需要注册到zookeeper中心；
    - 需要远程调用服务在zookeeper中声明自己需要的接口。
    - zookeeper将已经注册的接口通知给需要的服务；

    ##### 怎么复制对象，有几种方式
    在实际编程中，我们常常遇到这种情况，有一个对象A,在某一时刻A中的已经包含了一些有效值，此时肯能需要一个完全与
    A相同的对象B,并且此后B的任何改动都对A的值没有影响，A与B是两个独立的对象，但是B的初始值由A来确定。
    -  例如set方法将值赋予给另外一个对象。
    -  重写java.lang.object类中的clone方法。
    浅克隆： 实现cloneable接口，重写clone方法（super.clone()）,在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型
    对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。
    简单来讲，在浅克隆中，当对象被复制时候只复制他本身和其中办好的值类型的成员变量，而引用类型的成员对象并没有复制。
    ![](static/images/shallowClone.png)
      class  studengt implement Cloneable{
     @Override
        public Object clone() {
            Student stu = null;
            try{
                stu = (Student)super.clone();
            }catch(CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return stu;
        }
    }
    浅克隆只是复制了变量的引用，并没有真正开辟另一个空间，将值复制后再将引用返回给新对象。
    - 深克隆：为了达到真正的复制对象，而不是纯粹的引用复制，我们将address类可复制化。
    在深克隆中，无论原型对象的成员变量是值类型还是引用类型,都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。
    简单来讲深克隆中，除了对象本身被复制外，对象所包含的成员变量也讲复制。
    在java中如果要实现深克隆可用通过覆盖object中的clone方法实现，也可以通过序列化serialization等方式来实现。

    ![](static/images/deepClone.png)
   class Address implements Cloneable {
       private String add;

       public String getAdd() {
           return add;
       }

       public void setAdd(String add) {
           this.add = add;
       }

       @Override
       public Object clone() {
           Address addr = null;
           try{
               addr = (Address)super.clone();
           }catch(CloneNotSupportedException e) {
               e.printStackTrace();
           }
           return addr;
       }
   }

   class Student implements Cloneable{
       private int number;

       private Address addr;

       public Address getAddr() {
           return addr;
       }

       public void setAddr(Address addr) {
           this.addr = addr;
       }

       public int getNumber() {
           return number;
       }

       public void setNumber(int number) {
           this.number = number;
       }

       @Override
       public Object clone() {
           Student stu = null;
           try{
               stu = (Student)super.clone();   //浅复制
           }catch(CloneNotSupportedException e) {
               e.printStackTrace();
           }
           stu.addr = (Address)addr.clone();   //深度复制
           return stu;
       }
   }

    - 工具类BeanUtils和propertyUtils进行对象复制:两者都提供了copyProperties（）方法进行复制
     Studeng stu1=new Student("json",23)；
     student stu2=new Student2;
     BeanUtils.copyProperties(stu2,stu1);

     - 通过序列化实现对象的复制：序列化就是将对象写到流的过程，写到流中的对象是原有一个对象的一个拷贝，而原有对象仍然存在于内存中，通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用对象的成员变量。
     因此通过序列化将对象写到一个流中，而从流中将其读出来，可以实现深克隆。需要注意的是能实现序列化的对象其类必须实现
     serializable接口，否则无法实现序列化操作。













