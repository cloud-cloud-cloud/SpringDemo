    #### :snail: 设计模式
    ##### 设计模式平时编程时有没有用过， 说一下你常用的设计模式并举例说明这个设计模式用在哪个场景。
      设计模式只要考虑到编程的开闭模式，对应扩展是开放的，对于修改是关闭的。
      单列模式（当类里面只允许创建一个对象的时候，运用单列模式）
      线程安全懒汉模式（在synchronize方法里面判断当对象为null,创建对象）
      恶汉模式（在静态块创建对象，然后再方法里面返回这个对象）
      public class SingletonDemo4 {
          private static SingletonDemo4 instance = null;
          static{
              instance = new SingletonDemo4();
          }
          private SingletonDemo4(){}
          public static SingletonDemo4 getInstance(){
              return instance;
          }
      }
      **工厂模式**
      工厂角色，实例的产生，根据不同参数，返回不同的类的实现。
      例如说我们有一个sql语句方法的模板：里面包含了公共的，通用的方法，根据具体传递的参数，返回不同的内容。

      **策略模式**：例如说针对不同的算法，不同用户不同的折扣。
      - 我们创建一个策略接口：主要方法是折扣方法；
      - 折扣一，二..策略实现这个接口
      - 创建一个折扣策略上线问 ，创建接口参数，然后创建构造方法构建折扣策略-注入策略，然后创建一个方法用策略调用抽象方法

        //报价上下文角色
        public class QuoteContext {
            //持有一个具体的报价策略
           private IQuoteStrategy quoteStrategy;

          //注入报价策略
          public QuoteContext(IQuoteStrategy quoteStrategy){
            this.quoteStrategy = quoteStrategy;
        }

           //回调具体报价策略的方法
          public BigDecimal getPrice(BigDecimal originalPrice){
              return quoteStrategy.getPrice(originalPrice);
          }
       }
      - 在客户端调用策略报价上下文，具体实现。

     **观察者模式**：生产者和订阅者模型-----主动去订阅，不让生产者去推送。什么时候去订阅呢，那么就需要进行监听（观察者），
     例如说爸爸，妈妈，亦或者奶奶 需要在小孩醒后进行投喂他，但是什么时候醒不知道，那么可能就需要老爸是不是的去房间看看，这样就没办法做其他事情了。
     如果我们可以通过小孩醒了这个事件，然后主动去调用观察者（观察者具体有哪些内容），然后调用观察者背后的爸爸或者妈妈

     **迭代器模式**
     迭代器模式挺高一种方法顺序访问一个聚合对象中的各个元素，而又不暴露对象的内部表示。
     - 定义迭代器接口，常用的方法（判断下一个节点hasnext(),下一个元素 next()）;
     - 定义具体迭代器的角色：实现迭代器的接口方法
     - 定义容器角色：例如说list,map等
     - 定义具体的容器角色：实现定义的容器角色，
     - 然后容器角色去调用迭代器的迭代方法，不关心具体怎么实现迭代的。

     **模板方法模式**
     模板方法模式定义一个操作中的算法的骨架，将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构可重定义该算法的某些步骤
     例如说某些功能，在不同的对象展示不同的作用，但是 功能的框架是一样的。
     比如：我们会在一个类里面抽一个模板，这些模板包含了实现的一些流程，具体怎么实现就看子类怎么实现了
     在做数据采集的过程中，因为不同的三方数据返回的数据不同，所以解析方法不同，具体怎么实现就看子类了。
     调用过程传递的参数也不同。

     **适配器模式**
     **代理模式**


    ##### 设计模式的六大原则
    - 单一职责原则：一个类只负责一个功能领域
    - 开闭原则
    - 里氏替换原则 ：所有引用基类（父类）的地方都能透明使用其子类对象，能接受父类 的属性那么必然能接受子类（例如说父类是动物，子类是小狗）
    - 依赖倒置原则：抽象不应该依赖于细节，细节应道依赖抽象。换言之就是面对接口编程，而非针对实现进行编程。
    - 接口隔离原则：每个接口承担相对独立的角色- 角色隔离原则。
    - 迪米特法则：一个软件的实现尽可能的少于其他实体发生相互作用。高耦合，低内聚。
        “不和陌生人说话，只与你的直接朋友进行通信等“’
    ##### 什么是工厂模式？


    ##### 什么是抽象工厂模式


    ##### 说一下你实际应用过的场景？


    ##### 装饰者模式是什么样的？有什么用？


    ##### 装饰者模式和适配器模式的区别？


    ##### 单例模式你用在过哪个场景？用的是饿汉式单例还是懒汉式单例？


    ##### 观察者模式是什么？说一下使用场景


    ##### 享元模式有没有用过？它是如何实现的呢？


    ##### 说一下应用实际场景


    ##### 如果我要实现一个对象池，object pool（不是connection pool），你有什么好的设计模式可以与之对应？能否说一下思路//todo