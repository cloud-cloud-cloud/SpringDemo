
    #### :snail: 数据库


    ##### 数据库你是自己装过调优过？还是只是拿它做一个存储介质？
    数据库调优：数据分区，分库，分表，数据冗余筛选，数据镜像，做数据库集群

    **数据库四种事务隔离级别**
    - 串行化：一个事务在执行过程中完全看不到其他事务对数据库所做的更新（执行的时候不允许别的事务并发执行。事务串行化执行，事务串行haul执行，事务只能一个一个接着执行，不能并发的执行。）
    - 可重复读（repeatable read）:一个事务在执行的过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。
    - 读已提交数据(read commit)：一个事务在执行的过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的记录更新
    - 读未提交数据(read uncommited)：一个事务在执行过程中可以看到其他事务没有提交的新插入数据，而且能看到其他事务没有提交的对已有记录的更新。

     **区别于spring的事务管理**


    #####  mysql?
    ###### mysql索引详细介绍和正确的使用方法
   1. 索引对查询的速度有着至关重要的影响。
    **索引是存储引擎（myisam，innodb）用于快速查找记录的一种数据结构;**

   2.  索引的优点：
    - 大大减轻了服务器需要扫描的数据量，从而提高了数据的检索速度；
    - 帮助服务器避免排序和临时表；
    - 可以将随机i/o变为顺序I/O;
    3.索引的创建索引（从逻辑结构）
    - 主键索引  alter table 'table_name' add primary key 'index_name'('column');
    - 唯一索引 alter  table 'table_name' add unique 'index_name'('column');
    - 普通索引 alter table 'table_name' add index 'index_name'('column');
    - 全文索引 alter  table 'table_name' add fulltext 'index_name' ('column');
    - 组合索引  alter  table 'table_name' add index 'index_name' ('column1','column2',....);
    4.B+TREE索引规则（b+tree从数据结构区分）
     - 全值匹配是值和索引中的所有列进行匹配，例如说组合索引，和组合索引里面的所有字段进行匹配。
     - 匹配最左前缀：满足最左前缀查询条件的顺序与索引列的顺序无关，如：（city, user_name）、（age, city, user_name）
     - 匹配列前缀：匹配列的开头部分，如查询用户以m开头的所有用户： select  * from  user_test where user_name like 'm%';
    5. 高效的所有策略
     - 索引列不能是表达式的一部分，也不能作为函数的参数，否则无法使用索引查询；
     - 前缀索引：有时候需要索引很长的字符列，这样会增加索引的存储空间和降低索引的效率，一种方法是可以使用哈希索引，
     还有一种是可以使用前缀索引，前缀索引是选择字符列的前n个字符作为索引，这样就可以大大节约索引空间，从而提高索引效率
      前缀索引要选择足够长的前缀保证高的选择性，同时又不能太长；
      前缀索引的创建  alter  table  table_name add index index_name(index_column(length));
      - 使用前缀索引的注意点：前缀索引无法使用order by和group by已经用前缀索引做覆盖扫描。
      - 选择合适的所以列顺序；
      - ***聚集索引和非聚集索引（从物理结构）*：聚集索引决定数据在物理磁盘上的物理排序，一个表只能有一个聚集索引，如果定义了主键，那么innodb会通过主键来聚集数据，如果没有定义主键，那么innodb会选择一个唯一的非空的索引来代替。
      如果没有唯一的非空索引，那么innodb会隐式定义一个主键来作为聚集索引，聚集索引可以很大程度提高访问速度，因为聚集索引将索引和行数据保存到同一个B-tree中，所以找到索引就找到对应的数据。
      在使用聚集索引的时候避免使用随机聚集索引，例如说uuid,因为这样会产生大量的索引碎片和随机I/O,使得聚集索引性能很差。
      非聚集索引：与聚集索引不同的是非聚集索引并不决定数据在磁盘上面的物理排序，并且在B-TREE包含索引但是不包含行数据，行数据只有根据保存在B-TREE中的是索引指针找到对应的行数据，例如说上面建立的组合索引（name,city,nmae）就不是聚集索引。

      - 覆盖索引：如果一个索引（例如 组合索引）中包含索引要查询的字段的值，那么就称之为覆盖索引。
      SELECT user_name, city, age FROM user_test WHERE user_name = 'feinik' AND age > 25;
      因为要查询的字段（user_name, city, age）都包含在组合索引的索引列中，所以就使用了覆盖索引查询，查看是否使用了覆盖索引可以通过执行计划中的Extra中的值为Using index则证明使用了覆盖索引，覆盖索引可以极大的提高访问性能。

      - 然后使用索引进行排序： 使用索引进行排序需要满足两点： order by后面的列顺序要与组合索引的列顺序一直，且所有顺序列的顺序房型需要一致；
        所有查询的字段需要包含在索引列中，满足覆盖索引


    ###### mysql中调优有哪些点？我指的是mysql数据库层面的参数配置不是SQL
    在执行速度，如果不考虑高并发，对原子性操作没那么高要求会首先myisam。
    myisam和innodb优化：
    key_buffer_size对myisam非常重要，合理的值取决于索引大小，数据量和负载。
    innodb_buffer_pool_size 这个对innodb表来说非常重要。innodb相比myisam表对缓存更为敏感，innodb将数据和索引都存储起来，在默认的设置下，运行起来很慢，如果数据量大的时候，可以设置达到内存的70-80%，因为操作系统就不需要很大的内存了，将数据和索引都存储到起来。
    innodb_flush_logs_at_trx_commit  默认不修改这个值，innodb速度会比myisam满1000来倍，
    table_cache，当表数量很多的时候，要考虑设置修改这个缓存时间1024不再满足，因为一张表正在使用，打开一张表也会速度很慢。
    thread_cache — 线程的创建和销毁的开销可能很大，因为每个线程的连接/断开都需要。我通常至少设置为 16
    query_cache 如果你的应用程序有大量的读，而且没有应用程序的缓存，那么这个会很有用。不要把它设置太大了，因为想要维护它也需要不少开销，这会导致MySQL变慢。通 常设置为 32-512Mb

    ###### mysql免安装版如何注册为windows系统服务？


    ###### mysql中myisam与innodb的区别，至少5点
    innodb 支持事务处理；
    - 加锁处理
    - 持有外键
    - 持有行锁。。。。myisam只有表锁
    - delete是一行一行的删除
    - 跨平台可直接拷贝使用
    - 表格很难被压缩
    - innodb把数据和索引存放到表空间
    - 不保存表的具体行数，扫描表来计算有多少行
    - 不支持fulltext类型的索引
    - innodb中必须包含auto_increment类型字段的索引

    - myisam 不支持事务，回滚将造成不完全回滚，不具有原子性
    - 不支持外键
    - 支持全文搜索
    - 保存表的具体行数，不带where时，直接返回保存的行数
    - delete表时候，先drop表，然后重建表。。。
    - myisam表被存放到三个文件。frm文件存放表格定义，数据文件myd(mydata)，索引文件是myi(myindex)引伸
    - 跨平台很难直接拷贝
    - myisam中可以使用auto_increment类型字段建立联合索引
    - 表格可以被压缩
     **从物理角度索引**：聚簇索引和非聚簇索引，myisam是非聚簇索引，innodb是聚簇索引，他们在b+数上结构myisam主键和二级索引在存储存储上面没有区别，所有的节点都存储的索引，叶子节点存储索引和索引对于记录的地址信息。
     innodb是聚簇索引，他的主键索引和二级索引存储结构是有区别的。主键索引的叶子节点存储了行数据和主键值，二级索引的叶子节点存储了行的主键值，使用b+树
     作为索引的存储结构，非叶子节点存储的是索引的关键字，但是非叶子节点中的关键字找没有存储对应记录的具体内容或者内容地址。。叶子节点上的数据是主键和具体记录

     **聚簇索引的优势**
     -  由于行数据和叶子节点存储到一起，这样主键和行数据是一起被载入到内存的。找到叶子节点就可以立即将行数据返回了，如果按照主键id来组织数据，获得数据更快。
     - 辅助索引使用主键作为“指针”而不是使用地址值作为指针的好处是，减少了当出现了行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是innodb在移动行时候无序更新辅助索引中的这个指针。也就是行的位置。。使用聚簇索引就可以保证不管这个主键b+树
     的节点如果变化，辅助索引数不受影响。



    myISAM相对简单所以在效率上要由于innodb，如果系统读多，写少，对原子操作要求性低，就选择myisam。且myisam恢复速度快，可以用备份覆盖恢复。
    如果系统读少，写多。尤其是并发写入高的时候，innodb就是首选。

    mysql 默认的采用的是myisam，myisam不支持事务，innodb支持，innodb的autocommit默认是打开的。所以每条sql语句都备默认封装成一个事务，自动提交，这样会影响速度，所以最好将多条sql
    语句放到begin，commit中间，组成一个事务去提交。

    ###### MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的
      innodb的行锁是通过索引上的索引项进行加锁实现的。如果没有索引，innodb会通过隐藏的聚簇索引来对记录加锁。
      innodb行锁有三种情况：
      - 对索引项加锁
      - 对索引项之间的空隙，第一条记录前的间隙，最后一条记录之后的间隙加锁。
      - 前两种组合，对记录及其前面的间隙加锁。
      其实如果不适用索引条件检索数据，那么innodb将对表中的所有记录加锁，时间效果和myisam的表锁是一样的。

    ##### oracle

    ######在哪个版本的LINUX下安装的ORACLE几点几？安装时有什么地方需要注意的吗？


    ###### oracle的SGA有没有自己动手调过
    内存分配（SGA,PGA） SGA:是用于存储数据库信息的内存区，该信息为数据库进程所共享，它包含oracle服务器的数据和控制信息，他是在oracle服务器所驻留的计算机的实际内存中得以分配。如果实际内存不够再往虚拟内存中写。
oracle11 g只需要设置memory就可以了，不需要单独设置sga_max_size进行设置
设置memory_max_target ,memory_targe一般原则是无论内存的1/2，设置好了重启，sga_max_size会自动变成memory——max_target设置的值。

   show parameter age
   alter system set sga_max_size=4096M scope=spfile;
   shutdown immediate;
   startup

    ##### union select和or的区别？
    union select 他是取结果集，然后进行筛选重复值
    or 是取两个结果集

    ##### having和where的区别？
    两者都是筛选用的，having 用来筛选组，where是筛选记录

    select 职工号 from 职工 where 工资>1000。

    group by 职工号 having 工资>1000。

    select 工资 from 职工 where 工资>1000。

    group by 工资 having 工资>1000。

    ##### oracle索引有几种？（回答不出bitmap索引并说明其用途的不属于oracle熟练，只能叫oracle使用）
    - b-tree 树索引 oracle默认创建的就是b-树。
    - bitmap(位图索引)：位图索引特定于该列的几个枚举值的情况，例如说性别，标示字段只有0和1情况
    - 基于函数的索引：比如经常对某个字段做查询的时候是带函数操作的，那么此时箭一个函数索引就有价值了。
    - 分区索引和全局索引：
    - 反向索引：例如说一个员工的员工编号分布密集，10001.10002.10033.这样就不好利用服务器并行，如果反向之后就是10001,20001,33001这样就能高效的利用好并行运算。
    - hash索引：hash索引可能是访问数据库中数据最快的方法，但有自身的缺点。集群键上不同的值的数目必须在创建hash之前就要知道，需要在创建hash
    集群的时候指定这个值。使用hash索引必须要使用hash集群。例如说性别标示 我们就知道他只可能有男女这两个。

    ##### 分区表是什么？你用过吗？


    ##### 外键的概念知道吗？


    ###### 知道


    ###### 对数据库的外键有必要建索引吗？为什么要建，为什么不要建，都请说明理由
   需要使用索引，因为如果创建索引，当修改表数据的时候可能就造成锁全表了，而不是锁几行数据。

    ##### 数据库范式你知道吗？有几个？请说明
    常用的三种范式
     第一范式：强调的是列的原子性，不能再拆分为其他列。例如说电话号码可以拆分为家庭电话号码，公司电话号码。
     第二范式：强调列的原子性。英文就是表必须要有一个主键。另外就是没有包含在主键的列必须完全依赖于主键，而不能只依赖主键的一部分。
     第三范式：包含了第二范式。另外非主键的列也必须直接依赖于主键，不能存在传递依赖，例如说c依赖b ,b依赖主键A,那就属于传递依赖。

    ###### 有6种而不是三种->_->! ，至少回答出3种，它们分别是1NF，2NF，3NF，巴斯-科德范式（BCNF）、4NF和5NF（完美范式）


    ###### 反范式是什么？举个例子
     反范式是通过增加冗余数据和数据分组来提高数据库读性能的过程。
     其实相比较而言反而增加了复杂度，对性能影响也大，一般不满足第三范式我们都不考虑用反范式。

    ##### select count(1), select count(*), select count(字段)区别
   count(1)=count(0)=count(*)>count(col)
    count(*)因为有主键索引所以在速度来说其实和count(1)差不多


    ##### exists 和 in的区别

    exists是先执行外表，遍历外表然后看外表有没有数据和内表数据匹配上的，匹配上结果就放到结果集里面；
    in 是先遍历内查询，然后和外表做笛卡尔积，进行条件筛选，所以相对于in 内表比较小的时候速度更快。当内表小，主查询表数据大，且有索引的时候就用in；反之则用exists


    ##### having 和 group的区别
   having只能用在group by之后对分组结果进行筛选。
   例如说  select  * from student where score>=60 and name !='zh'
   group  by name having avg(score)>70; 先分组然后进行筛选  group by 通过某个字段进行分组，
   然后通过having进行筛选。

    ##### (S#,Sname,Sage,Ssex) 学生表 表Course 表SC（学生与课程的分数mapping 表）


    ######  按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按 如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分


    ######  查询各科成绩前三名的记录:(不考虑成绩并列情况)-高级


    ###### 查询出只选修了一门课程的全部学生的学号和姓名


    ###### 查询男生人数


    ###### 查询女生人数


    ######  查询任何一门课程成绩在70分以上的姓名、课程名称和分数


    ##### sql中的delete和truncate的区别？
    truncate table与delete 不带where条件功能是一样的都是删除表数据，但truncate删除数据不可恢复，不会存放到日志中，delete删除数据会放到日志里面，可以进行恢复
    另外delete可以和where条件进行删除，可以一行一行进行删除。

    ##### oracle的nvl和nvl2区别

    nvl(str1,str2)如果str1不为空返回str1,为空返回str2,都为空返回null  nvl(str,replace_with)
    nvl2(str1,str2,str3)str1为空返回str3,不为空返回str2

    数据库事务特性（一致性，原子性，隔离性，持久性）-银行转账系统


    ##### 如何读写分离

    ##### 存储过程

    ##### 视图
